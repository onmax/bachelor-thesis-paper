\subsection{Entrenamiento, validación y test de las redes neuronales}


Una vez creado los modelos, se ha codificado una función para automatizar el proceso de entrenamiento, validación y test de cada uno de los modelos y de además de obtener las métricas que se necesitarán para poder estudiar y comparar los distintos modelos. El código es el siguiente:

\begin{minted}[fontsize=\scriptsize]{python}

MAX_EPOCHS = 150

'''
Compiles and train model

@param model which will be training
@param window with the Datasets used
@param max_epoch for training
@param should_stop if detects overfitting the stops with a patience of 10
@param lr (learning rate) of the model
'''
def compile_and_fit(model, window, max_epochs=MAX_EPOCHS, should_stop=False, lr=0.001):
    model.compile(
        loss=tf.losses.Huber(),
        optimizer=tf.optimizers.Adam(lr=lr),
        metrics=[MeanSquaredLogarithmicError(), MeanSquaredError(), MeanAbsoluteError(),
                RootMeanSquaredError(), RootMeanSquaredLogarithmicError])
    
    # Define the callbacks for the training proccess
    # PlotLossesKeras plots training and validation for every epoch in real time
    # early_stopping allows to stop if detects overfitting
    cbs = [PlotLossesKeras()] + ([EarlyStopping(monitor='val_loss',
                                                      patience=10,
                                                      mode='min')] if should_stop else [])
    
    model.fit(window.train, epochs=max_epochs,
                        validation_data=window.val,
                        callbacks=cbs,
                        verbose=2)
    
'''
Computes metrics and returns it as DataFrame
'''
def get_metrics(model, window):
    train_metrics = model.evaluate(window.train)
    val_metrics = model.evaluate(window.val)
    test_metrics = model.evaluate(window.test)

    metrics_names = model.metrics_names
    metrics_names[0] = "huber"
    metrics = pd.DataFrame({
        "names": metrics_names,
        "train": train_metrics,
        "val": val_metrics,
        "test": test_metrics,
    })

    return metrics


windows_sizes=[(3, 1), (5, 1), (8, 1), (8, 3), (8, 5), (12, 1), 
                (12, 3), (12, 5), (24, 1), (24, 3), (24, 5)]

'''
Given a model it will train with different windows sizes

@param model which will be training
@param max_epoch for training
@param lr (learning rate) of the model
@param windows_sizes a list of tuples containing window sizes as (input, output)
'''
def model_generator(model, lr, max_epochs=150, windows_sizes=windows_sizes):
    # Loads and splits the DataFrames
    df = load_dataset()
    train_df, val_df, test_df = split_dataset(df)
    
    # For every windo
    for w in windows_sizes:
        # Create the windoe
        input_width, steps = r
        window = WindowGenerator(input_width=input_width,
                                 label_width=steps,
                                 shift=steps,
                                 train_df=train_df,
                                 val_df=val_df,
                                 test_df=test_df)

        
        # Train model
        compile_and_fit(
            model, window, lr=lr, should_stop=True, max_epochs=max_epochs)
        
        # Save metrics
        metrics = get_metrics(model, window)
        filename = "/path/to/results/{model.get_name()}" + \
                    "-{input_width}-{steps}.csv"
        metrics.to_csv(filename)
\end{minted}


Como se puede ver en el código, dado un modelo, la función se encarga de entrenar dicho modelo pero con distintas configuraciones de ventana y posteriormente guarda las métricas en un CSV. 